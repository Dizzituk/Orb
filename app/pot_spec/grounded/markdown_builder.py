# FILE: app/pot_spec/grounded/markdown_builder.py
"""
POT Spec Markdown Builder for SpecGate

This module builds the Point-of-Truth specification markdown output
in the required template format.

Responsibilities:
- Generate structured markdown from GroundedPOTSpec
- Include all sections: Goal, Reality, Scope, Constraints, Evidence, etc.
- Handle special sections: Multi-file ops, Multi-target read, Sandbox resolution
- Format scan parameters, implementation stack, assumptions, decisions

Key Features:
- v1.19: SCAN_ONLY job parameters section
- v1.33: Multi-file operation section
- v1.34: Multi-target read section
- v1.43: Full evidence (no truncation for grounded truth)

Used by:
- spec_runner.py for final markdown generation

Version: v2.0 (2026-02-01) - Extracted from spec_generation.py
"""

from __future__ import annotations

from .spec_models import GroundedPOTSpec


__all__ = [
    "build_pot_spec_markdown",
]


def build_pot_spec_markdown(spec: GroundedPOTSpec) -> str:
    """
    Build POT spec markdown in the required template format.
    
    Args:
        spec: GroundedPOTSpec with all grounded data
        
    Returns:
        Complete markdown string for the POT spec
    """
    lines = []
    
    # Title
    lines.append("# Point-of-Truth Specification")
    lines.append("")
    
    # Goal
    lines.append("## Goal")
    lines.append(spec.goal or "(Not specified)")
    lines.append("")
    
    # Current Reality
    lines.append("## Current Reality (Grounded Facts)")
    lines.append("")
    
    # v1.19: SCAN_ONLY job parameters
    if spec.scan_roots or spec.scan_terms:
        lines.append("### ğŸ” Scan Parameters (SCAN_ONLY Job)")
        lines.append("")
        if spec.scan_roots:
            lines.append(f"- **Scan roots:** {', '.join(f'`{r}`' for r in spec.scan_roots)}")
        if spec.scan_terms:
            lines.append(f"- **Search terms:** {', '.join(f'`{t}`' for t in spec.scan_terms)}")
        if spec.scan_targets:
            lines.append(f"- **Search targets:** {', '.join(spec.scan_targets)}")
        if spec.scan_case_mode:
            lines.append(f"- **Case mode:** {spec.scan_case_mode}")
        if spec.scan_exclusions:
            exclusions_display = spec.scan_exclusions[:5]
            if len(spec.scan_exclusions) > 5:
                exclusions_display.append(f"... and {len(spec.scan_exclusions) - 5} more")
            lines.append(f"- **Exclusions:** {', '.join(exclusions_display)}")
        lines.append("")
        lines.append("*Output: CHAT_ONLY (read-only scan, no file modification)*")
        lines.append("")
    
    # Sandbox Resolution
    if spec.sandbox_discovery_used and spec.sandbox_input_path:
        lines.append("### Sandbox File Resolution")
        lines.append(f"- **Input file:** `{spec.sandbox_input_path}`")
        
        output_mode = spec.sandbox_output_mode
        if output_mode == "rewrite_in_place":
            lines.append(f"- **Output mode:** REWRITE_IN_PLACE (multi-question insert)")
            lines.append(f"- **Output target:** `{spec.sandbox_input_path}`")
            if spec.sandbox_insertion_format:
                lines.append(f"- **Insertion format:** `{repr(spec.sandbox_insertion_format)}`")
        elif output_mode == "append_in_place":
            lines.append(f"- **Output mode:** APPEND_IN_PLACE (write into same file)")
            lines.append(f"- **Output target:** `{spec.sandbox_input_path}`")
            if spec.sandbox_insertion_format:
                lines.append(f"- **Insertion format:** `{repr(spec.sandbox_insertion_format)}`")
        elif output_mode == "separate_reply_file":
            lines.append(f"- **Output mode:** SEPARATE_REPLY_FILE")
            lines.append(f"- **Output target:** `{spec.sandbox_output_path}`")
        else:
            lines.append("- **Output mode:** CHAT_ONLY (no file modification)")
        
        if spec.sandbox_selected_type and spec.sandbox_selected_type.lower() != "unknown":
            lines.append(f"- **Content type:** {spec.sandbox_selected_type}")
        
        if spec.sandbox_input_excerpt:
            excerpt_lines = spec.sandbox_input_excerpt.split('\n')[:15]
            lines.append("")
            lines.append("**Input excerpt:**")
            lines.append("```")
            for el in excerpt_lines:
                lines.append(el)
            if len(spec.sandbox_input_excerpt.split('\n')) > 15:
                lines.append("... (truncated)")
            lines.append("```")
        lines.append("")
        
        if spec.sandbox_generated_reply:
            lines.append("### ğŸ“ Reply (Read-Only)")
            lines.append("")
            lines.append("*This reply was generated by SpecGate based on the file content.*")
            if output_mode == "rewrite_in_place":
                lines.append("*Later stages will insert answers under each question in the input file.*")
            elif output_mode == "append_in_place":
                lines.append("*Later stages will append this reply to the input file.*")
            elif output_mode == "separate_reply_file":
                lines.append("*Later stages will write this to reply.txt.*")
            else:
                lines.append("*This reply will be shown in chat only (no file modification).*")
            lines.append("")
            lines.append("```")
            lines.append(spec.sandbox_generated_reply)
            lines.append("```")
            lines.append("")
    elif spec.sandbox_discovery_status and spec.sandbox_discovery_status != "not_attempted":
        lines.append("### âš ï¸ Sandbox Discovery Status")
        lines.append(f"- **Status:** {spec.sandbox_discovery_status}")
        if spec.sandbox_skip_reason:
            lines.append(f"- **Reason:** {spec.sandbox_skip_reason}")
        lines.append("")
    
    # v1.34: Multi-Target Read Section (Level 2.5)
    if spec.is_multi_target_read and spec.multi_target_files:
        lines.append("### ğŸ“– Multi-Target Read")
        lines.append("")
        
        valid_files = [ft for ft in spec.multi_target_files if ft.found]
        total_files = len(spec.multi_target_files)
        
        lines.append(f"- **Total targets:** {total_files}")
        lines.append(f"- **Files found:** {len(valid_files)}")
        
        if len(valid_files) < total_files:
            missing = [ft.name for ft in spec.multi_target_files if not ft.found]
            lines.append(f"- **Missing:** {', '.join(missing)}")
        
        lines.append("")
        lines.append("**Files:**")
        for ft in spec.multi_target_files:
            status = "âœ…" if ft.found else "âŒ"
            location = f" ({ft.anchor}" + (f"/{ft.subfolder}" if ft.subfolder else "") + ")" if ft.anchor else ""
            lines.append(f"- {status} `{ft.name}`{location}")
            if ft.resolved_path and ft.found:
                lines.append(f"  - Path: `{ft.resolved_path}`")
            if ft.error:
                lines.append(f"  - Error: {ft.error}")
        
        lines.append("")
        
        # Include combined content if available
        if spec.sandbox_generated_reply:
            lines.append("**Combined Content:**")
            lines.append("```")
            # Truncate if very long
            reply_lines = spec.sandbox_generated_reply.split('\n')[:100]
            for line in reply_lines:
                lines.append(line)
            if len(spec.sandbox_generated_reply.split('\n')) > 100:
                lines.append("... (truncated)")
            lines.append("```")
        
        lines.append("")
    
    # v1.33: Multi-File Operation Section
    if spec.multi_file and spec.multi_file.is_multi_file:
        lines.append("### ğŸ” Multi-File Operation")
        mf = spec.multi_file
        
        lines.append(f"- **Type:** {mf.operation_type.upper()}")
        lines.append(f"- **Pattern:** `{mf.search_pattern}`")
        if mf.replacement_pattern:
            lines.append(f"- **Replace:** `{mf.replacement_pattern}`")
        lines.append(f"- **Files found:** {mf.total_files}")
        lines.append(f"- **Total occurrences:** {mf.total_occurrences}")
        
        if mf.roots_searched:
            lines.append(f"- **Roots searched:** {', '.join(mf.roots_searched[:3])}{'...' if len(mf.roots_searched) > 3 else ''}")
        
        if mf.discovery_duration_ms:
            lines.append(f"- **Discovery time:** {mf.discovery_duration_ms}ms")
        
        if mf.discovery_truncated:
            lines.append("- **Note:** Results truncated (too many matches)")
        
        if mf.requires_confirmation:
            status = "âœ… Confirmed" if mf.confirmed else "â³ Awaiting confirmation"
            lines.append(f"- **Confirmation:** {status}")
        
        if mf.error_message:
            lines.append(f"- **âš ï¸ Error:** {mf.error_message}")
        
        if mf.file_preview:
            lines.append("")
            lines.append("**Complete Evidence Report:**")
            lines.append("```")
            # v1.43: Show FULL evidence - no truncation for grounded truth
            # Critical Architecture needs complete file list to generate accurate implementation plan
            for line in mf.file_preview.split('\n'):
                lines.append(line)
            lines.append("```")
        lines.append("")
    
    if spec.confirmed_components:
        lines.append("### Confirmed Components/Files/Modules")
        for fact in spec.confirmed_components:
            conf = f" [{fact.confidence}]" if fact.confidence != "confirmed" else ""
            src = f" (source: {fact.source})" if fact.source else ""
            lines.append(f"- {fact.description}{conf}{src}")
        lines.append("")
    
    if spec.what_exists:
        lines.append("### What Exists Now")
        for item in spec.what_exists:
            lines.append(f"- {item}")
        lines.append("")
    
    if spec.what_missing:
        lines.append("### What Doesn't Exist (Gaps)")
        for item in spec.what_missing:
            lines.append(f"- {item}")
        lines.append("")
    
    # Scope
    lines.append("## Scope")
    lines.append("")
    lines.append("### In Scope")
    if spec.in_scope:
        for item in spec.in_scope:
            lines.append(f"- {item}")
    elif spec.sandbox_discovery_used and spec.sandbox_input_path:
        output_mode = spec.sandbox_output_mode
        if output_mode == "rewrite_in_place":
            lines.append("- Read file â†’ parse questions â†’ generate answers â†’ insert under each question")
        elif output_mode == "append_in_place":
            lines.append("- Read file â†’ generate reply â†’ append in place")
        elif output_mode == "separate_reply_file":
            lines.append("- Read file â†’ generate reply â†’ write to reply.txt")
        else:
            lines.append("- Read file â†’ generate reply â†’ present in chat")
    else:
        lines.append("- (To be determined)")
    lines.append("")
    
    lines.append("### Out of Scope")
    if spec.out_of_scope:
        for item in spec.out_of_scope:
            lines.append(f"- {item}")
    else:
        lines.append("- (None explicitly specified)")
    lines.append("")
    
    # Constraints
    lines.append("## Constraints")
    lines.append("")
    
    lines.append("### From Weaver Intent")
    if spec.constraints_from_intent:
        for c in spec.constraints_from_intent:
            lines.append(f"- {c}")
    else:
        lines.append("- (None specified)")
    lines.append("")
    
    lines.append("### Discovered from Repo")
    if spec.constraints_from_repo:
        for c in spec.constraints_from_repo:
            lines.append(f"- {c}")
    else:
        lines.append("- (None discovered)")
    lines.append("")
    
    # Evidence Used
    lines.append("## Evidence Used")
    lines.append("")
    if spec.evidence_bundle:
        for source in spec.evidence_bundle.sources:
            if source.found or source.error:
                lines.append(f"- {source.to_evidence_line()}")
    else:
        lines.append("- (No evidence collected)")
    lines.append("")
    
    if spec.evidence_gaps:
        lines.append("### âš ï¸ Evidence Gaps")
        lines.append("*The following evidence sources were unavailable, limiting grounding confidence:*")
        lines.append("")
        for gap in spec.evidence_gaps:
            lines.append(f"- {gap}")
        lines.append("")
    
    # Proposed Step Plan
    lines.append("## Proposed Step Plan")
    lines.append("*(Small, testable steps only)*")
    lines.append("")
    if spec.proposed_steps:
        for i, step in enumerate(spec.proposed_steps, 1):
            lines.append(f"{i}. {step}")
    else:
        lines.append("1. (Steps to be determined after questions resolved)")
    lines.append("")
    
    # Acceptance Tests
    lines.append("## Acceptance Tests")
    lines.append("")
    if spec.acceptance_tests:
        for test in spec.acceptance_tests:
            lines.append(f"- [ ] {test}")
    else:
        lines.append("- [ ] (To be determined)")
    lines.append("")
    
    # Risks + Mitigations
    lines.append("## Risks + Mitigations")
    lines.append("")
    if spec.risks:
        lines.append("| Risk | Mitigation |")
        lines.append("|------|------------|")
        for risk in spec.risks:
            lines.append(f"| {risk.get('risk', 'N/A')} | {risk.get('mitigation', 'N/A')} |")
    else:
        lines.append("| Risk | Mitigation |")
        lines.append("|------|------------|")
        lines.append("| (None identified) | - |")
    lines.append("")
    
    # Refactor Flags
    lines.append("## Refactor Flags (Recommendations Only)")
    lines.append("")
    if spec.refactor_flags:
        for flag in spec.refactor_flags:
            lines.append(f"- âš ï¸ {flag}")
    else:
        lines.append("- (None)")
    lines.append("")
    
    # Open Questions
    lines.append("## Open Questions (Human Decisions Only)")
    lines.append("")
    if spec.open_questions:
        if spec.is_complete and spec.spec_version >= 3:
            lines.append("âš ï¸ **FINALIZED WITH UNRESOLVED QUESTIONS** - These were NOT guessed or filled in:")
            lines.append("")
        for i, q in enumerate(spec.open_questions, 1):
            lines.append(f"### Question {i}")
            if spec.is_complete and spec.spec_version >= 3:
                lines.append("**Status:** â“ UNRESOLVED (no guess - human decision required)")
            lines.append(q.format())
            lines.append("")
    else:
        if spec.evidence_complete and not spec.evidence_gaps:
            lines.append("âœ… No blocking questions - all information grounded from evidence.")
        else:
            lines.append("âš ï¸ No questions generated, but evidence was incomplete (see Evidence Gaps above).")
    lines.append("")
    
    # Resolved Decisions
    if spec.decisions:
        lines.append("## Resolved Decisions")
        lines.append("")
        lines.append("*These were explicitly answered by the user.*")
        lines.append("")
        for key, value in spec.decisions.items():
            nice_key = key.replace("_", " ").title()
            lines.append(f"- **{nice_key}:** {value}")
        lines.append("")
    
    # Implementation Stack
    if spec.implementation_stack:
        lines.append("## ğŸ”§ Implementation Stack")
        lines.append("")
        if spec.implementation_stack.stack_locked:
            lines.append("âš ï¸ **STACK LOCKED** - Architecture MUST use this stack (user confirmed)")
        else:
            lines.append("*Stack detected from conversation - not explicitly locked*")
        lines.append("")
        if spec.implementation_stack.language:
            lines.append(f"- **Language:** {spec.implementation_stack.language}")
        if spec.implementation_stack.framework:
            lines.append(f"- **Framework:** {spec.implementation_stack.framework}")
        if spec.implementation_stack.runtime:
            lines.append(f"- **Runtime:** {spec.implementation_stack.runtime}")
        if spec.implementation_stack.source:
            lines.append(f"- **Source:** {spec.implementation_stack.source}")
        if spec.implementation_stack.notes:
            lines.append(f"- **Notes:** {spec.implementation_stack.notes}")
        lines.append("")
    
    # Assumptions
    if spec.assumptions:
        lines.append("## Assumptions (v1 Safe Defaults)")
        lines.append("")
        lines.append("*These were applied automatically instead of asking non-blocking questions.*")
        lines.append("*Override in spec if needed.*")
        lines.append("")
        for assumption in spec.assumptions:
            lines.append(f"- **{assumption.topic}:** {assumption.assumed_value}")
            lines.append(f"  - *Reason:* {assumption.reason}")
        lines.append("")
    
    # Blocking Issues
    if spec.blocking_issues:
        lines.append("---")
        lines.append("## â›” Blocking Issues")
        lines.append("")
        for issue in spec.blocking_issues:
            lines.append(f"- {issue}")
        lines.append("")
    
    # Unresolved Items Summary
    has_unresolved = (
        spec.open_questions or
        not spec.proposed_steps or
        not spec.acceptance_tests or
        "(To be determined)" in str(spec.in_scope)
    )
    if spec.is_complete and has_unresolved:
        lines.append("---")
        lines.append("## âš ï¸ Unresolved / Unknown (No Guess)")
        lines.append("")
        lines.append("*The following items remain unresolved. SpecGate did NOT fill these with assumptions:*")
        lines.append("")
        if spec.open_questions:
            lines.append(f"- **{len(spec.open_questions)} unanswered question(s)** - see above")
        if not spec.proposed_steps:
            lines.append("- **Steps:** Not specified (requires human input)")
        if not spec.acceptance_tests or all('(To be determined)' in str(t) for t in spec.acceptance_tests):
            lines.append("- **Acceptance tests:** Not specified (requires human input)")
        lines.append("")
    
    # Metadata
    lines.append("---")
    lines.append("## Metadata")
    lines.append(f"- **Spec ID:** `{spec.spec_id or 'N/A'}`")
    lines.append(f"- **Spec Hash:** `{spec.spec_hash[:16] if spec.spec_hash else 'N/A'}...`")
    lines.append(f"- **Version:** {spec.spec_version}")
    lines.append(f"- **Generated:** {spec.generated_at.isoformat()}")
    lines.append(f"- **Status:** {'Complete' if spec.is_complete else 'Awaiting answers'}")
    
    return "\n".join(lines)
