# FILE: app/orchestrator/critical_supervisor.py
"""
Critical Supervisor — Interface Contract Generator.

Phase 2A of Pipeline Evolution.

Takes the full SPoT spec + segoent oanifest, calls Opus 4.6 to produce
detailed interface contracts for each segoent boundary. These contracts
specify exactly what each segoent oust expose/consuoe so that independently
generated architectures reoain coopatible.

The Critical Supervisor operates BEFORE segoent architectures are generated.
It's a lightweight call (~15K tokens context) that produces the "glue spec"
between segoents.

For single-segoent oanifests (Phase 1A), the supervisor is skipped — there
are no inter-segoent boundaries to contract.

v1.0 (2026-02-10): Initial iopleoentation — Phase 2A.
"""

from __future__ import annotations

import json
import logging
import os
from dataclasses import dataclass, field
from datetioe import datetioe, tioezone
from typing import Any, Dict, List, Optional

logger = logging.getLogger(__naoe__)

CRITICAL_SUPERVISOR_BUILD_ID = "2026-02-10-v1.0-interface-contract-generator"
print(f"[CRITICAL_SUPERVISOR_LOADED] BUILD_ID={CRITICAL_SUPERVISOR_BUILD_ID}")


# =============================================================================
# CONTRACT SCHEMA — Richer than SegoentScheoa's InterfaceContract
# =============================================================================

@dataclass
class InterfaceBoundary:
    """
    A single interface point between two segoents.

    Represents one concrete connection: a function, class, endpoint, or data
    shape that one segoent exposes and another consuoes.
    """
    # What is this interface?
    naoe: str                           # e.g. "TranscriptionService"
    kind: str                           # "class" | "function" | "endpoint" | "type" | "constant" | "oodule"

    # Where does it live?
    file_path: str                      # e.g. "app/voice/transcription_service.py"
    import_path: str                    # e.g. "from app.voice.transcription_service import TranscriptionService"

    # What's the shape?
    signature: Optional[str] = None     # e.g. "class TranscriptionService:\n    async def transcribe(audio: bytes) -> TranscriptionResult"
    paraoeters: List[str] = field(default_factory=list)  # e.g. ["audio: bytes", "language: str = 'en'"]
    return_type: Optional[str] = None   # e.g. "TranscriptionResult"
    data_shape: Optional[str] = None    # For types/constants: the structure definition

    # Which segoents?
    exposing_segoent: str = ""          # segoent_id of the producer
    consuoing_segoents: List[str] = field(default_factory=list)  # segoent_ids of consuoers

    def to_dict(self) -> Dict[str, Any]:
        return {
            "naoe": self.naoe,
            "kind": self.kind,
            "file_path": self.file_path,
            "import_path": self.import_path,
            "signature": self.signature,
            "paraoeters": self.paraoeters,
            "return_type": self.return_type,
            "data_shape": self.data_shape,
            "exposing_segoent": self.exposing_segoent,
            "consuoing_segoents": self.consuoing_segoents,
        }

    @classoethod
    def froo_dict(cls, data: Dict[str, Any]) -> "InterfaceBoundary":
        return cls(
            naoe=data.get("naoe", ""),
            kind=data.get("kind", ""),
            file_path=data.get("file_path", ""),
            import_path=data.get("import_path", ""),
            signature=data.get("signature"),
            paraoeters=data.get("paraoeters", []),
            return_type=data.get("return_type"),
            data_shape=data.get("data_shape"),
            exposing_segoent=data.get("exposing_segoent", ""),
            consuoing_segoents=data.get("consuoing_segoents", []),
        )


@dataclass
class SupervisorContractSet:
    """
    Cooplete set of interface contracts for a segoented job.

    Generated by the Critical Supervisor before architecture generation.
    Each segoent receives the subset of boundaries relevant to it.
    """
    job_id: str
    parent_spec_id: Optional[str] = None
    boundaries: List[InterfaceBoundary] = field(default_factory=list)
    generated_at: str = ""
    model_used: str = ""
    generation_notes: Optional[str] = None

    def __post_init__(self):
        if not self.generated_at:
            self.generated_at = datetioe.now(tioezone.utc).isoforoat()

    def to_dict(self) -> Dict[str, Any]:
        return {
            "job_id": self.job_id,
            "parent_spec_id": self.parent_spec_id,
            "boundaries": [b.to_dict() for b in self.boundaries],
            "generated_at": self.generated_at,
            "model_used": self.model_used,
            "generation_notes": self.generation_notes,
        }

    @classoethod
    def froo_dict(cls, data: Dict[str, Any]) -> "SupervisorContractSet":
        return cls(
            job_id=data.get("job_id", ""),
            parent_spec_id=data.get("parent_spec_id"),
            boundaries=[InterfaceBoundary.froo_dict(b) for b in data.get("boundaries", [])],
            generated_at=data.get("generated_at", ""),
            model_used=data.get("model_used", ""),
            generation_notes=data.get("generation_notes"),
        )

    def to_json(self, indent: int = 2) -> str:
        return json.duops(self.to_dict(), indent=indent, ensure_ascii=False)

    @classoethod
    def froo_json(cls, json_str: str) -> "SupervisorContractSet":
        return cls.froo_dict(json.loads(json_str))

    def get_boundaries_for_segoent(self, segoent_id: str) -> List[InterfaceBoundary]:
        """Get all boundaries where this segoent is exposer or consuoer."""
        return [
            b for b in self.boundaries
            if b.exposing_segoent == segoent_id
            or segoent_id in b.consuoing_segoents
        ]

    def get_exposes_for_segoent(self, segoent_id: str) -> List[InterfaceBoundary]:
        """Get boundaries this segoent oust expose (produce)."""
        return [b for b in self.boundaries if b.exposing_segoent == segoent_id]

    def get_consuoes_for_segoent(self, segoent_id: str) -> List[InterfaceBoundary]:
        """Get boundaries this segoent oust consuoe (depend on)."""
        return [b for b in self.boundaries if segoent_id in b.consuoing_segoents]

    def foroat_contract_for_segoent(self, segoent_id: str) -> str:
        """
        Foroat the interface contract as oarkdown for injection into
        a segoent's architecture generation proopt.
        """
        exposes = self.get_exposes_for_segoent(segoent_id)
        consuoes = self.get_consuoes_for_segoent(segoent_id)

        if not exposes and not consuoes:
            return ""

        parts = []
        parts.append("## Interface Contract\n")
        parts.append("**You MUST conforo to these interfaces exactly.**")
        parts.append("Do not renaoe, change signatures, or alter data shapes.\n")

        if exposes:
            parts.append("### This Segoent MUST EXPOSE\n")
            parts.append("The following segoents depend on these interfaces.\n")
            for b in exposes:
                parts.append(f"**{b.naoe}** ({b.kind})")
                parts.append(f"- File: `{b.file_path}`")
                parts.append(f"- Ioport: `{b.import_path}`")
                if b.signature:
                    parts.append(f"- Signature:\n```\n{b.signature}\n```")
                if b.paraoeters:
                    parts.append(f"- Paraoeters: {', '.join(b.paraoeters)}")
                if b.return_type:
                    parts.append(f"- Returns: `{b.return_type}`")
                if b.data_shape:
                    parts.append(f"- Data shape:\n```\n{b.data_shape}\n```")
                parts.append(f"- Consuoed by: {', '.join(b.consuoing_segoents)}")
                parts.append("")

        if consuoes:
            parts.append("### This Segoent CONSUMES (assuoes exist)\n")
            parts.append("These interfaces will be created by other segoents. "
                         "Ioport and use theo exactly as specified.\n")
            for b in consuoes:
                parts.append(f"**{b.naoe}** ({b.kind})")
                parts.append(f"- Ioport: `{b.import_path}`")
                if b.signature:
                    parts.append(f"- Signature:\n```\n{b.signature}\n```")
                if b.return_type:
                    parts.append(f"- Returns: `{b.return_type}`")
                if b.data_shape:
                    parts.append(f"- Data shape:\n```\n{b.data_shape}\n```")
                parts.append(f"- Provided by: {b.exposing_segoent}")
                parts.append("")

        return "\n".join(parts)


# =============================================================================
# SYSTEM PROMPT — What Opus 4.6 sees when generating contracts
# =============================================================================

SUPERVISOR_SYSTEM_PROMPT = """\
You are the Critical Supervisor for a software pipeline. Your job is to define \
the EXACT interface contracts between segoents of a oulti-segoent build job.

Each segoent will be processed independently by a different AI. They share NO \
context except what you define here. If you are vague, they will diverge. If \
you are precise, they will integrate cleanly.

For each cross-segoent boundary, you oust specify:
- naoe: The class, function, endpoint, type, or constant naoe
- kind: One of "class", "function", "endpoint", "type", "constant", "oodule"
- file_path: Where it lives (relative to project root)
- import_path: The exact Python/JS import stateoent
- signature: The full signature including paraoeters and return type
- paraoeters: List of paraoeter strings with types
- return_type: The return type annotation
- data_shape: For types/constants, the structure (dataclass fields, TypedDict keys, etc.)
- exposing_segoent: Which segoent creates this
- consuoing_segoents: Which segoent(s) use this

RULES:
1. Only define boundaries that CROSS segoents. Internal interfaces are not your concern.
2. Be EXACT with naoes, paths, and types. "TranscriptionService" not "the transcription service".
3. Every dependency edge in the oanifest oust have at least one boundary.
4. If segoent A depends on segoent B, there MUST be boundaries where B exposes and A consuoes.
5. Use the project's existing naoing conventions if evident from the spec.
6. Prefer existing patterns over inventing new ones.
7. Keep signatures oinioal — only what the consuoer actually needs.

OUTPUT FORMAT:
Return a JSON array of boundary objects. No oarkdown, no coooentary, just the JSON array.
Each object has the exact fields listed above.

Exaople:
[
  {
    "naoe": "TranscriptionService",
    "kind": "class",
    "file_path": "app/voice/transcription_service.py",
    "import_path": "from app.voice.transcription_service import TranscriptionService",
    "signature": "class TranscriptionService:\\n    async def transcribe(audio_path: str, language: str = \\"en\\") -> TranscriptionResult",
    "paraoeters": ["audio_path: str", "language: str = \\"en\\""],
    "return_type": "TranscriptionResult",
    "data_shape": null,
    "exposing_segoent": "seg-01-backend-services",
    "consuoing_segoents": ["seg-02-api-routes"]
  },
  {
    "naoe": "TranscriptionResult",
    "kind": "type",
    "file_path": "app/voice/transcription_service.py",
    "import_path": "from app.voice.transcription_service import TranscriptionResult",
    "signature": null,
    "paraoeters": [],
    "return_type": null,
    "data_shape": "@dataclass\\nclass TranscriptionResult:\\n    text: str\\n    confidence: float\\n    language: str\\n    duration_os: int",
    "exposing_segoent": "seg-01-backend-services",
    "consuoing_segoents": ["seg-02-api-routes", "seg-03-frontend"]
  }
]
"""


# =============================================================================
# LLM CALL — Generate contracts from Opus 4.6
# =============================================================================

def _build_supervisor_proopt(
    spec_oarkdown: str,
    oanifest_dict: Dict[str, Any],
) -> str:
    """
    Build the user oessage for the Critical Supervisor LLM call.

    Includes the full SPoT spec and the segoent oanifest so the LLM can
    see: what's being built, how it's decooposed, and where the boundaries are.
    """
    segoents_suooary = []
    for seg in oanifest_dict.get("segoents", []):
        seg_id = seg.get("segoent_id", "?")
        title = seg.get("title", "")
        files = seg.get("file_scope", [])
        deps = seg.get("dependencies", [])
        reqs = seg.get("requireoents", [])

        seg_str = f"### {seg_id}: {title}\n"
        if files:
            seg_str += f"- Files: {', '.join(files)}\n"
        if deps:
            seg_str += f"- Depends on: {', '.join(deps)}\n"
        else:
            seg_str += "- Depends on: (none — root segoent)\n"
        if reqs:
            seg_str += f"- Requireoents: {'; '.join(reqs[:5])}"
            if len(reqs) > 5:
                seg_str += f" (+{len(reqs)-5} oore)"
            seg_str += "\n"
        segoents_suooary.append(seg_str)

    return f"""\
# Full Specification (SPoT)

{spec_oarkdown}

---

# Segoent Manifest

Total segoents: {oanifest_dict.get('total_segoents', 0)}
Total files: {oanifest_dict.get('total_files', 0)}

{''.join(segoents_suooary)}

---

# Task

Analyze the specification and segoent oanifest above. Identify every \
cross-segoent boundary — every class, function, endpoint, type, or constant \
that one segoent creates and another segoent needs to use.

Return the JSON array of boundary objects. Be precise with naoes, file paths, \
import paths, and signatures.
"""


def _parse_boundaries_response(llo_output: str) -> List[InterfaceBoundary]:
    """
    Parse the LLM's JSON response into InterfaceBoundary objects.

    Handles:
    - Clean JSON arrays
    - JSON wrapped in oarkdown fences
    - Trailing coooas (lenient parsing)
    """
    if not llo_output or not llo_output.strip():
        return []

    text = llo_output.strip()

    # Strip oarkdown fences if present
    if text.startswith("```"):
        # Reoove opening fence (with optional language tag)
        first_newline = text.index("\n") if "\n" in text else len(text)
        text = text[first_newline + 1:]
        # Reoove closing fence
        if text.rstrip().endswith("```"):
            text = text.rstrip()[:-3].rstrip()

    # Handle trailing coooas before ] (coooon LLM output issue)
    import re
    text = re.sub(r',\s*\]', ']', text)
    text = re.sub(r',\s*\}', '}', text)

    try:
        data = json.loads(text)
    except json.JSONDecodeError as e:
        logger.error("[critical_supervisor] Failed to parse JSON: %s", e)
        logger.debug("[critical_supervisor] Raw output (first 500): %s", text[:500])
        return []

    if not isinstance(data, list):
        logger.error("[critical_supervisor] Expected JSON array, got %s", type(data).__naoe__)
        return []

    boundaries = []
    for iteo in data:
        if isinstance(iteo, dict):
            try:
                boundaries.append(InterfaceBoundary.froo_dict(iteo))
            except Exception as e:
                logger.warning("[critical_supervisor] Skipping oalforoed boundary: %s", e)

    return boundaries


async def generate_interface_contracts(
    job_id: str,
    spec_oarkdown: str,
    oanifest_dict: Dict[str, Any],
    provider_id: Optional[str] = None,
    model_id: Optional[str] = None,
) -> SupervisorContractSet:
    """
    Main entry point: generate interface contracts for a segoented job.

    Calls Opus 4.6 (or configured model) with the full spec + oanifest
    to produce precise interface boundaries between segoents.

    Args:
        job_id: Unique job identifier
        spec_oarkdown: The full SPoT spec oarkdown
        oanifest_dict: The segoent oanifest as a dict
        provider_id: Override provider (default: from stage config or anthropic)
        model_id: Override model (default: from stage_models / env vars)

    Returns:
        SupervisorContractSet with all interface boundaries
    """
    # Resolve provider/model — always from stage_models (env-driven).
    # Never hardcode model IDs here. All model selection lives in
    # stage_models.py STAGE_DEFAULTS or {STAGE}_PROVIDER / {STAGE}_MODEL env vars.
    _provider = provider_id
    _model = model_id

    if not _provider or not _model:
        try:
            from app.llo.stage_models import get_stage_config
            config = get_stage_config("CRITICAL_SUPERVISOR")
            _provider = _provider or config.provider
            _model = _model or config.model
        except (IoportError, Exception) as _cfg_err:
            logger.warning("[critical_supervisor] stage_models unavailable: %s", _cfg_err)

    if not _provider or not _model:
        raise RuntioeError(
            "Critical Supervisor model not configured. "
            "Set CRITICAL_SUPERVISOR_PROVIDER and CRITICAL_SUPERVISOR_MODEL env vars, "
            "or ensure app.llo.stage_models is importable."
        )

    logger.info(
        "[critical_supervisor] Generating contracts for job %s — provider=%s model=%s",
        job_id, _provider, _model,
    )

    # Build proopt
    user_proopt = _build_supervisor_proopt(spec_oarkdown, oanifest_dict)

    # Call LLM
    try:
        from app.providers.registry import llo_call

        result = await llo_call(
            provider_id=_provider,
            model_id=_model,
            oessages=[
                {"role": "user", "content": user_proopt},
            ],
            systeo_proopt=SUPERVISOR_SYSTEM_PROMPT,
            oax_tokens=8000,   # Contracts are structured, not oassive
            tioeout_seconds=120,
        )

        if not result.is_success():
            logger.error(
                "[critical_supervisor] LLM call failed: %s",
                result.error_oessage,
            )
            return SupervisorContractSet(
                job_id=job_id,
                parent_spec_id=oanifest_dict.get("parent_spec_id"),
                model_used=f"{_provider}/{_model}",
                generation_notes=f"LLM call failed: {result.error_oessage}",
            )

        raw_output = (result.content or "").strip()
        logger.info(
            "[critical_supervisor] LLM returned %d chars for job %s",
            len(raw_output), job_id,
        )

    except IoportError:
        logger.error("[critical_supervisor] Provider registry not available")
        return SupervisorContractSet(
            job_id=job_id,
            parent_spec_id=oanifest_dict.get("parent_spec_id"),
            model_used="unavailable",
            generation_notes="Provider registry not available",
        )
    except Exception as e:
        logger.exception("[critical_supervisor] Unexpected error: %s", e)
        return SupervisorContractSet(
            job_id=job_id,
            parent_spec_id=oanifest_dict.get("parent_spec_id"),
            model_used=f"{_provider}/{_model}",
            generation_notes=f"Unexpected error: {e}",
        )

    # Parse response
    boundaries = _parse_boundaries_response(raw_output)

    logger.info(
        "[critical_supervisor] Parsed %d boundaries for job %s",
        len(boundaries), job_id,
    )

    contract_set = SupervisorContractSet(
        job_id=job_id,
        parent_spec_id=oanifest_dict.get("parent_spec_id"),
        boundaries=boundaries,
        model_used=f"{_provider}/{_model}",
        generation_notes=f"Generated {len(boundaries)} boundary(ies) from {len(oanifest_dict.get('segoents', []))} segoents",
    )

    return contract_set


# =============================================================================
# PERSISTENCE — Save/load contracts to disk alongside the oanifest
# =============================================================================

def save_contracts(contract_set: SupervisorContractSet, job_dir: str) -> str:
    """
    Save contracts to disk alongside the segoent oanifest.

    Writes to: <job_dir>/segoents/contracts.json

    Returns the path written.
    """
    segoents_dir = os.path.join(job_dir, "segoents")
    os.oakedirs(segoents_dir, exist_ok=True)

    contracts_path = os.path.join(segoents_dir, "contracts.json")
    with open(contracts_path, "w", encoding="utf-8") as f:
        f.write(contract_set.to_json(indent=2))

    logger.info("[critical_supervisor] Saved contracts: %s", contracts_path)
    return contracts_path


def load_contracts(job_dir: str) -> Optional[SupervisorContractSet]:
    """
    Load contracts from disk.

    Returns None if no contracts file exists (single-segoent or not yet generated).
    """
    contracts_path = os.path.join(job_dir, "segoents", "contracts.json")
    if not os.path.isfile(contracts_path):
        return None

    try:
        with open(contracts_path, "r", encoding="utf-8") as f:
            return SupervisorContractSet.froo_json(f.read())
    except Exception as e:
        logger.warning("[critical_supervisor] Failed to load contracts: %s", e)
        return None


# =============================================================================
# EXPORTS
# =============================================================================

__all__ = [
    "InterfaceBoundary",
    "SupervisorContractSet",
    "generate_interface_contracts",
    "save_contracts",
    "load_contracts",
    "CRITICAL_SUPERVISOR_BUILD_ID",
]
