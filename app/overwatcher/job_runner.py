# FILE: app/overwatcher/job_runner.py
"""Simple Job Runner: Push jobs through Overwatcher pipeline.

Provides a simple interface to test the full pipeline:
1. Create a job spec
2. Execute via sandbox (or local)
3. Write output

Usage:
    from app.overwatcher.job_runner import run_simple_job
    
    result = await run_simple_job(
        task="Write a hello world text file",
        output_target="DESKTOP",
        output_filename="hello.txt",
    )
"""

from __future__ import annotations

import asyncio
import logging
import os
from dataclasses import dataclass, field
from datetime import datetime, timezone
from typing import Any, Callable, Dict, List, Optional
from uuid import uuid4

from app.overwatcher.sandbox_client import (
    SandboxClient,
    SandboxError,
    get_sandbox_client,
)

logger = logging.getLogger(__name__)


# =============================================================================
# Job Models
# =============================================================================

@dataclass
class SimpleJob:
    """A simple job for testing."""
    job_id: str
    task: str
    output_target: str  # DESKTOP, DOCUMENTS, SCRATCH, ARTIFACT
    output_filename: str
    output_content: Optional[str] = None
    status: str = "pending"  # pending, running, completed, failed
    error: Optional[str] = None
    created_at: str = ""
    completed_at: str = ""
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "job_id": self.job_id,
            "task": self.task,
            "output_target": self.output_target,
            "output_filename": self.output_filename,
            "output_content": self.output_content,
            "status": self.status,
            "error": self.error,
            "created_at": self.created_at,
            "completed_at": self.completed_at,
        }


@dataclass
class JobResult:
    """Result of a job execution."""
    success: bool
    job: SimpleJob
    output_path: Optional[str] = None
    sha256: Optional[str] = None
    duration_ms: int = 0
    sandbox_used: bool = False
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "success": self.success,
            "job": self.job.to_dict(),
            "output_path": self.output_path,
            "sha256": self.sha256,
            "duration_ms": self.duration_ms,
            "sandbox_used": self.sandbox_used,
        }


# =============================================================================
# Content Generators
# =============================================================================

def generate_text_content(task: str, filename: str) -> str:
    """Generate simple text content based on task description."""
    now = datetime.now(timezone.utc).isoformat()
    
    # Simple content generation based on task keywords
    task_lower = task.lower()
    
    if "hello" in task_lower or "test" in task_lower:
        content = f"""Hello from Orb Overwatcher!
=====================================

This file was generated by the Overwatcher pipeline.

Task: {task}
Filename: {filename}
Generated: {now}
Job Runner Version: 1.0.0

This is a test of the sandbox bridge integration.
The file was written via the Windows Sandbox controller.

If you can read this, the pipeline is working!
"""
    elif "report" in task_lower:
        content = f"""# Overwatcher Report
Generated: {now}

## Task
{task}

## Status
Pipeline execution successful.

## Details
- Output file: {filename}
- Generated via sandbox bridge
"""
    elif "log" in task_lower:
        content = f"""[{now}] INFO: Overwatcher job started
[{now}] INFO: Task: {task}
[{now}] INFO: Output: {filename}
[{now}] INFO: Job completed successfully
"""
    else:
        content = f"""Overwatcher Output
==================

Task: {task}
File: {filename}
Time: {now}

Content generated by Orb Overwatcher pipeline.
"""
    
    return content


# =============================================================================
# Job Execution
# =============================================================================

async def run_simple_job(
    task: str,
    output_target: str = "DESKTOP",
    output_filename: str = "orb_output.txt",
    output_content: Optional[str] = None,
    subdir: Optional[str] = None,
    use_sandbox: bool = True,
    client: Optional[SandboxClient] = None,
) -> JobResult:
    """Run a simple job through the Overwatcher pipeline.
    
    Args:
        task: Description of what to do
        output_target: Where to write (DESKTOP, DOCUMENTS, SCRATCH, ARTIFACT)
        output_filename: Name of output file
        output_content: Specific content to write (auto-generates if None)
        subdir: Optional subdirectory within target
        use_sandbox: Whether to use sandbox (falls back to local if unavailable)
        client: Optional SandboxClient instance
    
    Returns:
        JobResult with execution details
    """
    import time
    start_time = time.time()
    
    # Create job
    job = SimpleJob(
        job_id=str(uuid4()),
        task=task,
        output_target=output_target,
        output_filename=output_filename,
        created_at=datetime.now(timezone.utc).isoformat(),
    )
    
    logger.info(f"[job_runner] Starting job {job.job_id}: {task}")
    job.status = "running"
    
    # Generate content if not provided
    if output_content is None:
        output_content = generate_text_content(task, output_filename)
    
    job.output_content = output_content
    
    # Try sandbox execution
    sandbox_used = False
    output_path = None
    sha256 = None
    
    if use_sandbox:
        try:
            if client is None:
                client = get_sandbox_client()
            
            if client.is_connected():
                logger.info(f"[job_runner] Using sandbox for job {job.job_id}")
                
                result = client.write_file(
                    target=output_target,
                    filename=output_filename,
                    content=output_content,
                    subdir=subdir,
                    overwrite=True,
                )
                
                if result.ok:
                    sandbox_used = True
                    output_path = result.path
                    sha256 = result.sha256
                    job.status = "completed"
                    job.completed_at = datetime.now(timezone.utc).isoformat()
                    
                    logger.info(f"[job_runner] Job {job.job_id} completed via sandbox: {output_path}")
                else:
                    raise SandboxError("Write returned not ok")
            else:
                logger.warning("[job_runner] Sandbox not connected, falling back to local")
                
        except SandboxError as e:
            logger.warning(f"[job_runner] Sandbox failed: {e}, falling back to local")
    
    # Fallback to local if sandbox not used
    if not sandbox_used:
        try:
            from pathlib import Path
            import hashlib
            
            # Determine local path
            if output_target == "DESKTOP":
                # Check for OneDrive Desktop first
                onedrive_desktop = Path.home() / "OneDrive" / "Desktop"
                standard_desktop = Path.home() / "Desktop"
                if onedrive_desktop.exists():
                    base = onedrive_desktop / "OrbTest"
                else:
                    base = standard_desktop / "OrbTest"
            elif output_target == "DOCUMENTS":
                # Check for OneDrive Documents first
                onedrive_docs = Path.home() / "OneDrive" / "Documents"
                standard_docs = Path.home() / "Documents"
                if onedrive_docs.exists():
                    base = onedrive_docs / "OrbTest"
                else:
                    base = standard_docs / "OrbTest"
            elif output_target == "SCRATCH":
                base = Path("D:/Orb/_sandbox_cache/scratch")
            elif output_target == "ARTIFACT":
                base = Path("D:/Orb/_sandbox_cache/jobs")
            else:
                base = Path("D:/Orb/_sandbox_cache/output")
            
            if subdir:
                base = base / subdir
            
            base.mkdir(parents=True, exist_ok=True)
            out_path = base / output_filename
            
            # Write file
            content_bytes = output_content.encode("utf-8")
            out_path.write_bytes(content_bytes)
            
            output_path = str(out_path)
            sha256 = hashlib.sha256(content_bytes).hexdigest()
            job.status = "completed"
            job.completed_at = datetime.now(timezone.utc).isoformat()
            
            logger.info(f"[job_runner] Job {job.job_id} completed locally: {output_path}")
            
        except Exception as e:
            job.status = "failed"
            job.error = str(e)
            logger.error(f"[job_runner] Job {job.job_id} failed: {e}")
            
            duration_ms = int((time.time() - start_time) * 1000)
            return JobResult(
                success=False,
                job=job,
                duration_ms=duration_ms,
                sandbox_used=sandbox_used,
            )
    
    duration_ms = int((time.time() - start_time) * 1000)
    
    return JobResult(
        success=job.status == "completed",
        job=job,
        output_path=output_path,
        sha256=sha256,
        duration_ms=duration_ms,
        sandbox_used=sandbox_used,
    )


async def run_shell_job(
    command: str,
    cwd_target: str = "REPO",
    timeout_seconds: int = 60,
    client: Optional[SandboxClient] = None,
) -> Dict[str, Any]:
    """Run a shell command via sandbox.
    
    Args:
        command: PowerShell command to run
        cwd_target: Working directory (REPO, SCRATCH, ARTIFACT)
        timeout_seconds: Command timeout
        client: Optional SandboxClient instance
    
    Returns:
        Dict with command results
    """
    if client is None:
        client = get_sandbox_client()
    
    if not client.is_connected():
        return {
            "success": False,
            "error": "Sandbox not connected",
            "sandbox_used": False,
        }
    
    try:
        result = client.shell_run(
            command=command,
            cwd_target=cwd_target,
            timeout_seconds=timeout_seconds,
        )
        
        return {
            "success": result.ok,
            "exit_code": result.exit_code,
            "stdout": result.stdout,
            "stderr": result.stderr,
            "duration_ms": result.duration_ms,
            "sandbox_used": True,
        }
        
    except SandboxError as e:
        return {
            "success": False,
            "error": str(e),
            "sandbox_used": True,
        }


# =============================================================================
# CLI Interface
# =============================================================================

def main():
    """Command-line interface for job runner."""
    import argparse
    
    parser = argparse.ArgumentParser(description="Orb Overwatcher Job Runner")
    parser.add_argument("task", nargs="?", default="Write a test file", help="Task description")
    parser.add_argument("--target", "-t", default="DESKTOP", choices=["DESKTOP", "DOCUMENTS", "SCRATCH", "ARTIFACT"], help="Output target")
    parser.add_argument("--filename", "-f", default="orb_test.txt", help="Output filename")
    parser.add_argument("--content", "-c", help="Specific content to write")
    parser.add_argument("--subdir", "-s", help="Subdirectory within target")
    parser.add_argument("--no-sandbox", action="store_true", help="Skip sandbox, write locally")
    parser.add_argument("--shell", help="Run a shell command instead of writing a file")
    
    args = parser.parse_args()
    
    async def run():
        if args.shell:
            print(f"Running shell command: {args.shell}")
            result = await run_shell_job(args.shell)
            print(f"Success: {result.get('success')}")
            print(f"Exit code: {result.get('exit_code')}")
            print(f"Sandbox used: {result.get('sandbox_used')}")
            if result.get('stdout'):
                print(f"Stdout:\n{result.get('stdout')}")
            if result.get('stderr'):
                print(f"Stderr:\n{result.get('stderr')}")
        else:
            print(f"Running job: {args.task}")
            print(f"Target: {args.target}")
            print(f"Filename: {args.filename}")
            
            result = await run_simple_job(
                task=args.task,
                output_target=args.target,
                output_filename=args.filename,
                output_content=args.content,
                subdir=args.subdir,
                use_sandbox=not args.no_sandbox,
            )
            
            print(f"\nResult:")
            print(f"  Success: {result.success}")
            print(f"  Sandbox used: {result.sandbox_used}")
            print(f"  Output path: {result.output_path}")
            print(f"  SHA256: {result.sha256}")
            print(f"  Duration: {result.duration_ms}ms")
            
            if not result.success:
                print(f"  Error: {result.job.error}")
    
    asyncio.run(run())


if __name__ == "__main__":
    main()


__all__ = [
    "SimpleJob",
    "JobResult",
    "generate_text_content",
    "run_simple_job",
    "run_shell_job",
]